# REST API – URL Shortener

**Сервис сокращения URL:** Хранение и управление короткими ссылками, преобразующимися в полные URL.

**Логирование и аналитика:** Отслеживание использования сокращенных ссылок.

**Прототипирование:** Быстрое развертывание(с помощью GitHub Actions) простого URL-шортенера для личных или корпоративных нужд.

------

### Библиотеки

- `go-chi/chi/v5` – маршрутизатор HTTP для Go
  - `go-chi/chi/v5/render` – для сериализации и десериализации
- `ilyakaznacheev/cleanenv` – работа с конфигурационными файлами и переменными окружения
- `log/slog` – для логирования в Go
- `mattn/go-sqlite3` – предоставляет драйвер для SQLite в Go
- `stretchr/testify` – для тестирования в Go
  - `stretchr/testify/assert` – функции для утверждения в текстах
  - `stretchr/testify/mock` – для генерации макетов, создание мок-объектов в тестах
  - `stretchr/testify/require` – функции для обязательных проверок в тестах
- `vektra/mockery` – инструмент для автоматической генерации мок-объектов в Go

------
### TODO

- [ ] #3 Добавить метод `DeleteURL`
- [ ] #4.3.0 Handler `Delete`
- [ ] #4.4.0 тестируем Handler `Delete`

------

## #0 Подготовительный процесс

- В последующем все указанные пути будут указываться от корня проекта – `./`

- Перетягиваем все необходимые пакеты для проекта 

  - `go get` <path>

- Создаём проект в корневой папке 

  - `go mod init` <name>

- Структура проекта:

  ```markdown
  ├──cmd
  │   └── url-shortener
  ├──internal
  │   ├── config
  │   ├── http-server
  │   │   ├── handlers
  │   │   │   ├── redirect
  │   │   │   │  └── mocks
  │   │   │   └── url
  │   │   │      └── save
  │   │   │         └── mocks
  │   │   └── middleware
  │   │       └── logger
  │   ├── lib
  │   │   ├── api
  │   │   │   └── response
  │   │   ├── random
  │   │   └── logger
  │   │       └── slogdiscard
  │   └── storage
  │       └── sqlite 
  ├── storage
  └── test
  ```

------

## #1 Конфигурация приложения

Конфигурация может использоваться для запуска приложения в разных средах окружения(local, dev, prod). Она определяет, где хранить данные(путь к базе данных) и как настроить сервер для обработки HTTP-запросов.

1. Создаём папку в корне проекта и сам файл внутри директории в формате `yaml`
   - путь: `config/local.yaml`
   - будем хранить файлы с конфигурациями (вариации запуска для различных окружений)
   - `local.yaml` включает параметры и настройки приложения, которые определяют его поведение в локальной среде


> *в проекте рабочий процесс по данной подграфе будет указан как* `#1.1`

2. Создаём необходимые папки и файлы для структуры под конфигурации:

   - путь: `project/internal/config/config.go`

   - в `config.go` заведём структуры, в которые будем анмаршалить конфигурационный файл:

     - `type Config struct{}`

     - `type HTTPServer struct{}`

   - используем следующие `struct-tags`: 

     - `yaml` — имя соответствующего параметра в `yaml-файле`,
     - `env-default` — дефолтное значение,
     - `env-required` — делает параметры обязательными. Если такой параметр не указан, мы будем получать ошибку 

> *в проекте рабочий процесс по данной подграфе будет указан как* `#1.2`

3. Напишем функцию, которая будет возвращать заполненную структуру

- путь: `internal/config/config.go`

- именуем функцию `func MustLoad() *Config {}`

  - приставка `Must` в имени функции означает что функция будет завершать работу приложения аварийно — `panic`
  - в случае когда приложение падает из за кривого `config` файла это вполне оправданно
  - путь до `config` файла мы получим из переменной окружения `CONFIG_PATH`


> *в проекте рабочий процесс по данной подграфе будет указан как* `#1.3`

4. Создадим директории в корне проекта `cmd/url-shortener` и внутри файл `main.go`
   - Будем конфигурировать и запускать наш сервис — в том числе используем функцию из пакета `config` `MustLoad()`

> *в проекте рабочий процесс по данной подграфе будет указан как* `#1.4`

------

### #2 Настройка логгера - slog

Важно учитывать уровни логгирования — если мы установим уровень `Info`, то  `Debug` сообщения не увидим. Поэтому для локальной разработки и `dev-environment` используем уровень `Debug`, а для продакшена — `Info`

1. Для удобства вынесем создание логгера в отдельную функцию:
   - `cmd/url-shortener/main.go` 

   - В зависимости от окружения эта функция создаёт логгер с разными параметрами

     ​	**TextHandler** | **JSONHandler** и уровень **LevelDebug** | **LevelInfo** 

> *в проекте рабочий процесс по данной подграфе будет указан как* `#2.1`

2. Теперь создадим логер в функции `main`, добавим параметр `env` с помощью метода `log.With(slog.String())` и выведем информацию о запуске приложения:

   - к каждому сообщение будет добавляться поле с информацией о текущем окружении

   - помимо сообщения будет выводиться параметр с адресом
     - `log.Info("txt", slog.String("address", env.Address))`

> *в проекте рабочий процесс по данной подграфе будет указан как* `#2.2`

------

### #3 Пишем Storage

Реализуем простое хранилище на базе SQLite для URL-shortener. Хранить будем всего одну сущность — ссылку с двумя полями: 

- `url` – длинный адрес, который мы сохраняем 
- `alias` – короткий идентификатор, по которому будем искать оригинальный адрес

1. путь: `internal/storage/storage.go`
   - Код по обработке специфичных ошибок, связанных с отсутствием или дублированием URL в хранилище.

> *в проекте рабочий процесс по данной подграфе будет указан как* `#3.1`

2. Cоздаём папку `sqlite` и создадим структуру для объекта `Storage`

- `struct Storage struct {db *sql.DB}`

> *в проекте рабочий процесс по данной подграфе будет указан как*  `#3.2`

3. Опишем методы хранилища

   - путь: `internal/storage/sqlite/sqlite.go`

   - `SaveURL()` and `GetURL()`
     1. **Подключение к базе данных:** С помощью конструктора `New` создается подключение к SQLite базе данных, инициализируется таблица для хранения URL и их коротких алиасов.
     2. **Сохранение URL:** Функция `SaveURL` сохраняет длинный URL и его короткий алиас в базу данных. Если алиас уже существует, возвращается соответствующая ошибка.
     3. **Получение URL:** Функция `GetURL` возвращает оригинальный URL по его короткому алиасу. Если алиас не найден, возвращается ошибка.

> *в проекте рабочий процесс по данной подграфе будет указан как*  `#3.3`

4. Подготовка HTTP Server
   - В `main.go` создадим объект роутера и подключим к нему необходимый `middleware`

> *в проекте рабочий процесс по данной подграфе будет указан как* `#3.4`

5. Работаем над собственным `middleware` для легирования запросов

   - `./internal/http-server/middleware/logger/logger.go`

   - В данном коде создается middleware (промежуточное ПО) для веб-сервера на Go, который логирует информацию о каждом HTTP-запросе.

   - Прописываем наш собственный логгер под `middleware` `mwLogger`

> *в проекте рабочий процесс по данной подграфе будет указан как* `#3.5`

------

## #4 Handlers — обработчики

### #4.1.0 Handler Save — сохранение нового URL

1. Создадим пакет `sl` - доп-й функционал для логгера пригодиться в **Handlers**
   - путь: `internal/lib/logger/sl/sl.go`
   - функционал для работы с логгером

> *в проекте рабочий процесс по данной подграфе будет указан как* `#4.1.1`

2. Save — сохранение нового URL

- `./internal/http-server/handlers/url/save/save.go`
- Заведем сразу две структуры - Request и Response 

> *в проекте рабочий процесс по данной подграфе будет указан как* `#4.1.2`

3. Так же вынесем в отдельный пакет `Response` структуру `Response` со свойствами `Status` и `Error`

- `./internal/lib/api/response/response.go`
- эти поля могут присутствовать в ответе любого хэндлера (обработчика)

> *данную часть кода пишем до кода* `#4.1.2`
> *в проекте рабочий процесс по данной подграфе будет указан как* `#4.1.3`

4. Провалидируем запрос

- Используем `go-playground/validator/v10`

> *в проекте рабочий процесс по данной подграфе будет указан как* `#4.1.4`

5. Так же реализуем функцию `NewRandomString` 

- `./internal/lib/random/random.go`

- Функция будет отрабатывать в `save.go` в функции `URLSaver` для генерации `alias`

> *в проекте рабочий процесс по данной подграфе будет указан как* `#4.1.5`

------

### #4.2.0 Handler Redirect – перенаправление на сохранённый URL

1. Прописываем Get-запрос под функцию реализованную в `internal/storage/sqlite` `GetURL`
   - путь: `internal/http-server/handlers/redirect/`

> *в проекте рабочий процесс по данной подграфе будет указан как* `#4.2.1`

2. Подключаем новый handler в main

> *в проекте рабочий процесс по данной подграфе будет указан как* `#4.2.2`

------

## #5 Тестируем Handlers

### #5.1.0 Тестируем Handler Save

1. Напишем свой — `DiscardHandler` (понадобиться в тестах для игнорирования сообщений логгера)
   - путь: `internal/lib/logger/handlers/slogdiscard/slogdiscard.go`
   - В таком виде логгер будет игнорировать все сообщения, которые мы в него отправляем, — это понадобится в тестах
   - Создадим пакет `slogdiscard` и имплементируем в нем интерфейс `slog.Handler`

2. За место настоящего `storage` будет использовать `mock`.

   - Используем пакет `vektra/mockery` для моков

   - Добавляем строку в `save.go` над `type URLSaver interface{}`
     - `//go:generate go run github.com/vektra/mockery/v2@v2.45 --name=URLSaver`

   - Далее запускаем `go generate ./..` либо при помощи `IDE`
     - сгенерируется папка рядом с `save.go` `mocks`

3. Пишем сам тест для `save.go`
   - создадим — `save_test.go` рядом с `save.go`
     - классический табличный тест `table cases`

4. Возвращаемся в `main` и добавляем наш первый handler(обработчик) в роутер
   - Убедиться что приложение запускается и отправить запросы

> *в проекте рабочий процесс по данной подграфе будет указан как* `#5.1.1`



------

### #5.2.0 Тестируем Handler Redirect



------

































