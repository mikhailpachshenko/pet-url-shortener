# REST API – URL Shortener

### Библиотеки:

- `go-chi/chi/v5` – маршрутизатор HTTP для Go
  - `go-chi/chi/v5/render` – для сериализации и десериализации
- `ilyakaznacheev/cleanenv` – работа с конфигурационными файлами и переменными окружения
- `log/slog` – для логирования в Go
- `stretchr/testify` – для тестирования в Go
  - `stretchr/testify/assert` – функции для утверждения в текстах
  - `stretchr/testify/mock` – для генерации макетов, создание мок-объектов в тестах
  - `stretchr/testify/require` – функции для обязательных проверок в тестах
- `mattn/go-sqlite3` – предоставляет драйвер для SQLite в Go
- `vektra/mockery` – инструмент для автоматической генерации мок-объектов в Go

------
### TODO:
------

## #0 Подготовительный процесс

- В последующем все указанные пути будут указываться от корня проекта – `./`

- Перетягиваем все необходимые пакеты для проекта

- Структура проекта:

  ```markdown
  ├──cmd
  │   └── url-shortener
  ├──internal
  │   ├── config
  │   ├── http-server
  │   │   ├── handlers
  │   │   │   ├── redirect
  │   │   │   │  └── mocks
  │   │   │   └── url
  │   │   │      └── save
  │   │   │         └── mocks
  │   │   └── middleware
  │   │       └── logger
  │   ├── lib
  │   │   ├── api
  │   │   │   └── response
  │   │   ├── random
  │   │   └── logger
  │   │       └── slogdiscard
  │   └── storage
  │       └── sqlite 
  ├── storage
  └── test
  ```

------

## #1 Конфигурация приложения

1. ##### Создаём папку в корне проекта и сам файл внутри директории в формате `yaml`

   - путь: `config/local.yaml`
   - будем хранить файлы с конфигурациями (вариации запуска)
   - `config` включает параметры и настройки приложения, которые определяют его поведение
   - *В проекте рабочий процесс по данной подграфе будет указан как* `#1.1`

2. ##### Создаём 

   - ##### `project/internal/config/config.go`

   - Создам необходимые папки и файлы

     - `mkdir -p internal/config  `
     - `touch internal/config/config.go`

   - В `config.go` заведём структуры, в которые будем анмаршалить конфигурационный файл:

     - `type Config struct{}`
     - `type HTTPServer struct{}`

   - Используем следующие `struct-tags`: 

     - `yaml` — имя соответствующего параметра в `yaml-файле`,
     - `env-default` — дефолтное значение,
     - `env-required` — делает параметры обязательными. Если такой параметр не указан, мы будем получать ошибку 

   - *В проекте рабочий процесс по данной подграфе будет указан как* `#1.2`

3. ##### Напишем функцию, которая будет возвращать заполненную структуру

   - `internal/config/config.go`

   - Именуем функцию `func MustLoad() *Config {}`

     - Приставка `Must` в имени функции означает что функция будет завершать работу приложения аварийно — `panic`

       *В случае когда приложение падает из за кривого `config` файла это вполне оправданно*

   - Путь до `config` файла мы получим из переменной окружения `CONFIG_PATH`

4. ##### Создадим директории в корне проекта `cmd/url-shortener` и внутри файл `main.go`

   - Будем конфигурировать и запускать наш сервис — в том числе используем функцию из пакета `config` `MustLoad()`

------

### #2 Настройка логгера - slog

Важно учитывать уровни логирования — если мы установим уровень `Info`, то  `Debug` сообщения не увидим. Поэтому для локальной разработки и `dev-environment` используем уровень `Debug`, а для продакшена — `Info`

1. Для удобства вынесем создание логгера в отдельную функцию
   - `cmd/url-shortener/main.go` 
   - Рабочий процесс под кодом `#2.1`
   - В зависимости от окружения эта функция создаёт логгер с разными параметрами 
     - *TextHandler | JSONHandler и уровень LevelDebug | LevelInfo*
2. Теперь создадим логгер в функции `main`, добавим параметр `env` с помощью метода `log.With` `slog.String` и выведем информацию о запуске приложения:
   - К каждому сообщение будет добавляться поле с информацией о текущем окружении
   - Помимо сообщения будет выводиться параметр с адресом
     - `log.Info("txt", slog.String("address", env.Address))`
   - Рабочий процесс под кодом `#2.2`
3. Напишем свою — `DiscardHandler`
   - В таком виде логгер будет игнорировать все сообщения, которые мы в него отправляем, — это понадобится в тестах
   - Создадим пакет `slogdiscard` и имплементируем в нем интерфейс `slog.Handler`
   - `internal/lib/logger/handlers/slogdiscard/slogdiscard.go`
   - Рабочий процесс под кодом `#2.3`
4. Создадим пакет `sl`
   - `internal/lib/logger/sl/sl.go`
   - Функционал для работы с логгером
   - Рабочий процесс под кодом `#2.4`































